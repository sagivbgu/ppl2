;; Signature: map(func,lst)
;; Purpose: Apply func to all elements in lst and return the list of the results
;; Type: [ (T1->T2) * List(T1) -> List(T2)]
;; Example: map((lambda (x) (+ 2 x)), '(1 2 3) ) should return '(3 4 5)
;; Pre-conditions: None
;; Post-condition: '(func(lst[0]) func(lst[1]) ... func(lst[n-1]))
;; Tests: (map (lambda (x) (+ 2 x)) '(1 2 3) )) ==> '(3 4 5)
(define map
  (lambda (func lst)
    (if (empty? lst)
        '()
        (cons (func (car lst))
              (map func (cdr lst))))))

;; Signature: reduce(reducer, init, l)
;; Purpose: Combine all the values of l using reducer
;; Type: [(T1 * T2 -> T2) * T2 * List(T1) -> T2]
;; Example: (reduce + 0 '(1 2 3)) --> (+ 1 (+ 2 (+ 3 0)))
;; Pre-conditions: None
;; Post-condition: None
;; Tests: (reduce + 0 '(1 2 3)) ==> 6
(define reduce
  (lambda (reducer init l)
    (if (empty? l)
        init
        (reducer (car l) 
                 (reduce reducer init (cdr l))))))

;; Signature:length-of-lst(lst)
;; Purpose: calculate the length of the given list
;; Type: [List(T) -> Number]
;; Pre-conditions: None
;; Post-condition: None
;; Tests: (length-of-lst (list 1 2 3)) → 3
(define length-of-lst
  (lambda (lst)
    (if (eq? lst '())
         0
         (+ 1 (length-of-lst(cdr lst))))))

;; Signature: last-element(lst)
;; Purpose: Return the last element of a given list
;; Type: [List(T) -> T]
;; Example: (last-element (list 1 3 4)) --> (car (cdr (cdr '(1 3 4))))
;; Pre-conditions: lst is not empty
;; Post-condition: None
;; Tests: (last-element (list 1 3 4)) ==> 4
(define last-element
  (lambda (lst)
    (if (eq? '() (cdr lst))
        (car lst)
        (last-element (cdr lst)))))

;; Signature: power(n1, n2)
;; Purpose: Return n1 to the power of n2 (n1^n2)
;; Type: [number * number -> number]
;; Example: (power 2 4) -> (* 2 (* 2 (* 2 2)))
;; Pre-conditions: n1 and n2 are non-negative numbers
;; Post-condition: None
;; Tests: (power 2 4) ==> 16
(define power
    (lambda (n1 n2)
        (cond ((= 0 n2) 1)
              ((= 1 n2) n1)
              (else (* n1 (power n1 (- n2 1)))))))

;; Signature: sum-lst-power(lst, n)
;; Purpose: apply power on each element of lst, and then sum the results
;; Type: [List(Number) * Number -> Number]
;; Example: (sum-lst-power (list 1 4 2) 3) → 1^3+ 4^3 + 2^3 = 73
;; Pre-conditions: n >= 0
;; Post-condition: Result = (+ (power lst[0] n) (+ ... powerlst[n]) ... )
;; Tests: (sum-lst-power (list 1 4 2) 3) ==> 1^3+ 4^3 + 2^3 = 73
(define sum-lst-power
    (lambda (lst n)
      (reduce + 0 (map (lambda (x) (power x n)) lst))))
  
;; Signature: remove-last-element(lst)
;; Purpose: Return a copy of the given list without its last element
;; Type: [List(T) -> List(T)]
;; Example: (last-element (list 1 3 4)) --> (cons 1 (cons 3 (cons 4 '())))
;; Pre-conditions: None
;; Post-condition: None
;; Tests: (remove-last-element (list 1 3 4)) ==> '(1 3)
(define remove-last-element
  (lambda (lst)
    (if (eq? '() (cdr lst))
        '()
        (cons (car lst) (remove-last-element (cdr lst))))))

;; Signature: num-from-digits(lst)
;; Purpose: Return the number consisted from lst's digits
;; Type: [List(number) -> number]
;; Pre-conditions: All of the numbers in lst are not negative
;; Post-condition: None
;; Tests: (num-from-digits (list 2 4 6)) ==> 246
(define num-from-digits
  (lambda (lst)
    (if (eq? lst '())
        0
        (+ (last-element lst) (* 10 (num-from-digits (remove-last-element lst)))))))

;; Signature:is-narcissistic(lst)
;; Purpose: Find out if a number is narcissistic (equals to the sum of its digits each
;;          raised to the power of the number of its digits)
;; Type: [List(number) -> boolean]
;; Pre-conditions: All of the numbers in lst are not negative
;; Post-condition: None
;; Tests: (is-narcissistic (list 1 5 3)) → #t
;; Tests: (is-narcissistic (list 1 2 3)) → #f
(define is-narcissistic
  (lambda (lst)
      (if (eq? (sum-lst-power lst (length-of-lst lst)) (num-from-digits lst) )
      #t
      #f)))