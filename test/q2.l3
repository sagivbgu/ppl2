;; Signature: map(func,lst)
;; Purpose: Apply func to all elements in lst and return the list of the results
;; Type: [ (T1->T2) * List(T1) -> List(T2)]
;; Example: map((lambda (x) (+ 2 x)), '(1 2 3) ) should return '(3 4 5)
;; Pre-conditions: None
;; Post-condition: '(func(lst[0]) func(lst[1]) ... func(lst[n-1]))
;; Tests: (map (lambda (x) (+ 2 x)) '(1 2 3) )) ==> '(3 4 5)
(define map
  (lambda (func lst)
    (if (empty? lst)
        '()
        (cons (func (car lst))
              (map func (cdr lst))
        )
    )
   )
)

;; Signature: reduce(reducer, init, l)
;; Purpose: Combine all the values of l using reducer
;; Type: [(T1 * T2 -> T2) * T2 * List(T1) -> T2]
;; Example: (reduce + 0 '(1 2 3)) --> (+ 1 (+ 2 (+ 3 0)))
;; Pre-conditions: None
;; Post-condition: None
;; Tests: (reduce + 0 '(1 2 3)) ==> 6
(define reduce
  (lambda (reducer init l)
    (if (empty? l)
        init
        (reducer (car l) 
                 (reduce reducer init (cdr l))))))

;; Signature: last-element(lst)
;; Purpose: Return the last element of a given list
;; Type: [List(T) -> T]
;; Example: (last-element (list 1 3 4)) --> (car (cdr (cdr '(1 3 4))))
;; Pre-conditions: lst is not empty
;; Post-condition: None
;; Tests: (last-element (list 1 3 4)) ==> 4
(define last-element
  (lambda (lst)
    (if (eq? '() (cdr lst))
        (car lst)
        (last-element (cdr lst)))))

;; Signature: power(n1, n2)
;; Purpose: Return n1 to the power of n2 (n1^n2)
;; Type: [number * number -> number]
;; Example: (power 2 4) -> (* 2 (* 2 (* 2 2)))
;; Pre-conditions: n1 and n2 are non-negative numbers
;; Post-condition: None
;; Tests: (power 2 4) ==> 16
(define power
    (lambda (n1 n2)
        (cond ((= 0 n2) 1)
              ((= 1 n2) n1)
              (else (* n1 (power n1 (- n2 1)))))))

;; Signature: sum-lst-power(lst, n)
;; Purpose: apply power on each element of lst, and then sum the results
;; Type: [List(Number) * Number -> Number]
;; Example: (sum-lst-power (list 1 4 2) 3) â†’ 1^3+ 4^3 + 2^3 = 73
;; Pre-conditions: n >= 0
;; Post-condition: Result = (+ (power lst[0] n) (+ ... powerlst[n]) ... )
;; Tests: (sum-lst-power (list 1 4 2) 3) ==> 1^3+ 4^3 + 2^3 = 73
(define sum-lst-power
    (lambda (lst n)
      (reduce + 0 (map (lambda (x) (power x n)) lst))
    )
)
      
  
(define num-from-digits
  (lambda (lst)
     @TODO
  )
)

(define is-narcissistic
  (lambda (lst)
       @TODO
    )
)
 
